program shift

  use w90_constants
  use w90_parameters
  use w90_io
  use w90_kmesh
  use w90_comms
  use w90_postw90_common
  use w90_dos
  use w90_berry
  use w90_spin
  use w90_kpath
  use w90_kslice
  use w90_boltzwann
  use w90_geninterp
  use w90_utility
  use w90_wan_ham
  use w90_get_oper
  use w90_spin

  !!! HERE IS MY DECLARATION
  implicit none
  integer       :: nkp, len_seedname
  logical       :: have_gamma
  real(kind=dp) :: time0,time1,time2
  character(len=9) :: stat,pos
  logical :: wpout_found, werr_found

  real(kind=dp), allocatable:: kpts(:,:)
  real(kind=dp) :: kpt(3)
  integer :: i,j,n,m,k,a_unit,u_unit,temp_unit,mnkpt

  complex(kind=dp), allocatable :: HH(:,:)
  complex(kind=dp), allocatable :: delHH(:,:,:)
  complex(kind=dp), allocatable :: UU(:,:)
  complex(kind=dp), allocatable :: D_h(:,:,:)
  complex(kind=dp), allocatable :: AA(:,:,:)
  real(kind=dp), allocatable :: del_eig(:,:)
  real(kind=dp), allocatable :: eig(:)
  real(kind=dp), allocatable :: occ(:)

  !!! END OF MY DECLARATION

  ! Put some descriptive comments here
  !
  call comms_setup

  library = .false.
  ispostw90 = .true.

  if(on_root) then
     time0=io_time()
     call io_get_seedname
     len_seedname = len(seedname)
  end if
  call comms_bcast(len_seedname,1)
  call comms_bcast(seedname,len_seedname)

  if (on_root) then
     ! If an error file (generated by postw90) exists, I delete it
     ! Note: I do it only for the error file generated from the root node;
     ! If error files generated by other nodes exist, I don't do anything for them
     inquire(file=trim(seedname)//'.node_00000.werr',exist=werr_found)
     if (werr_found) then
        stdout=io_file_unit()
        open(unit=stdout,file=trim(seedname)//'.node_00000.werr',status='old',position='append')
        close(stdout,status='delete')
     end if

     inquire(file=trim(seedname)//'.wpout',exist=wpout_found)
     if (wpout_found) then
        stat='old'
     else
        stat='replace'
     endif
     pos='append'

     stdout=io_file_unit()
     open(unit=stdout,file=trim(seedname)//'.wpout',status=trim(stat),position=trim(pos))

     call param_write_header
     if(num_nodes==1) then
#ifdef MPI
        write(stdout,'(/,1x,a)') 'Running in serial (with parallel executable)'
#else
        write(stdout,'(/,1x,a)') 'Running in serial (with serial executable)'
#endif
     else
        write(stdout,'(/,1x,a,i3,a/)')&
             'Running in parallel on ',num_nodes,' CPUs'
     endif
  end if

  ! Read onto the root node all the input parameters from seendame.win,
  ! as well as the energy eigenvalues on the ab-initio q-mesh from seedname.eig
  !
  if(on_root) then
       call param_read
       call param_postw90_write
       time1=io_time()
       write(stdout,'(1x,a25,f11.3,a)')&
            'Time to read parameters  ',time1-time0,' (sec)'

       if(.not.effective_model) then
          ! Check if the q-mesh includes the gamma point
          !
          have_gamma=.false.
          do nkp=1,num_kpts
             if (all(abs(kpt_latt(:,nkp))<eps6)) have_gamma=.true.
          end do
          if(.not. have_gamma) write(stdout,'(1x,a)')&
               'Ab-initio does not include Gamma. Interpolation may be incorrect!!!'
          !
          ! Need nntot, wb, and bk to evaluate WF matrix elements of
          ! the position operator in reciprocal space. Also need
          ! nnlist to compute the additional matrix elements entering
          ! the orbital magnetization
          !
          call kmesh_get
          time2=io_time()
          write(stdout,'(1x,a25,f11.3,a)')&
               'Time to get kmesh        ',time2-time1,' (sec)'
       endif

       ! GP, May 10, 2012: for the moment I leave this commented
       ! since we need first to tune that routine so that it doesn't
       ! print the memory information related to wannier90.x.
       ! Note that the code for the memory estimation for the
       ! Boltzwann routine is already there.
       !       call param_memory_estimate
  end if

  ! We now distribute a subset of the parameters to the other nodes
  !
  call wanint_param_dist

  if(.not.effective_model) then
     !
     ! Read files seedname.chk (overlap matrices, unitary matrices for
     ! both disentanglement and maximal localization, etc.)
     !
     if(on_root) call param_read_chkpt()
     !
     ! Distribute the information in the um and chk files to the other nodes
     !
     ! Ivo: For interpolation purposes we do not need u_matrix_opt and
     !      u_matrix separately, only their product v_matrix, and this
     !      is what is distributed now
     !
     call wanint_data_dist
  end if

  ! Read list of k-points in irreducible BZ and their weights
  !
  ! Should this be done on root node only?
  !
  if(wanint_kpoint_file) call wanint_get_kpoint_file

  ! Setup a number of common variables for all interpolation tasks
  !
  call wanint_setup

  if(on_root) then
     time1=io_time()
     write(stdout,'(/1x,a25,f11.3,a)')&
          'Time to read and process .chk    ',time1-time2,' (sec)'
  endif

  ! Now perform one or more of the following tasks

  ! ---------------------------------------------------------------
  ! Density of states calculated using a uniform interpolation mesh
  ! ---------------------------------------------------------------
  !
  if(dos .and. index(dos_task,'dos_plot')>0) call dos_main

! find_fermi_level commented for the moment in dos.F90
!  if(dos .and. index(dos_task,'find_fermi_energy')>0) call find_fermi_level

  ! --------------------------------------------------------------------
  ! Bands, Berry curvature, or orbital magnetization plot along a k-path
  ! --------------------------------------------------------------------
  !
  if(kpath) call k_path

  ! ---------------------------------------------------------------------------
  ! Bands, Berry curvature, or orbital magnetization plot on a slice in k-space
  ! ---------------------------------------------------------------------------
  !
  if(kslice) call k_slice

  ! --------------------
  ! Spin magnetic moment
  ! --------------------
  !
  if(spin_moment) call get_spin_moment

  ! -------------------------------------------------------------------
  ! dc Anomalous Hall conductivity and eventually (if 'mcd' string also
  ! present in addition to 'ahe', e.g., 'ahe+mcd') dichroic optical
  ! conductivity, both calculated on the same (adaptively-refined) mesh
  ! -------------------------------------------------------------------
  !
  ! ---------------------------------------------------------------
  ! Absorptive dichroic optical conductivity & JDOS on uniform mesh
  ! ---------------------------------------------------------------
  !
  ! -----------------------------------------------------------------
  ! Absorptive ordinary optical conductivity & JDOS on a uniform mesh
  ! -----------------------------------------------------------------
  !
  ! -----------------------------------------------------------------
  ! Orbital magnetization
  ! -----------------------------------------------------------------
  !
  if(berry) call berry_main
  ! -----------------------------------------------------------------
  ! Boltzmann transport coefficients (BoltzWann module)
  ! -----------------------------------------------------------------
  !
  ! ---------------------------------------------------------------
  ! HERE IS MY PROGRAM
  ! ---------------------------------------------------------------
  !

  allocate(HH(num_wann,num_wann))
  allocate(delHH(num_wann,num_wann,3))
  allocate(UU(num_wann,num_wann))
  allocate(D_h(num_wann,num_wann,3))
  allocate(AA(num_wann,num_wann,3))
  allocate(del_eig(num_wann,3))
  allocate(eig(num_wann))
  allocate(occ(num_wann))
  call get_HH_R
  call get_AA_R
  temp_unit = io_file_unit()
  open(temp_unit, file='kpts.dat')
  read(temp_unit, *) mnkpt
  allocate(kpts(mnkpt, 3))
  read(temp_unit, *) kpts
  close(temp_unit)
  a_unit = io_file_unit()
  open(a_unit, file='A.dat', ACTION="write", STATUS="replace")
  u_unit = io_file_unit()
  open(u_unit, file='U.dat', ACTION="write", STATUS="replace")
  do k=1,mnkpt
    kpt = kpts(k,:)
    write(a_unit, '("kpt: ",F14.7," ",F14.7," ",F14.7)') kpt(1),kpt(2),kpt(3)
    write(u_unit, '("kpt: ",F14.7," ",F14.7," ",F14.7)') kpt(1),kpt(2),kpt(3)
    call fourier_R_to_k_new(kpt,HH_R,OO=HH,&
                                     OO_dx=delHH(:,:,1),&
                                     OO_dy=delHH(:,:,2),&
                                     OO_dz=delHH(:,:,3))
    call utility_diagonalize(HH,num_wann,eig,UU)
    write(a_unit, *) eig
    call get_occ(eig,occ,fermi_energy_list(1))
    call get_D_h(delHH,UU,eig,D_h)
    call fourier_R_to_k_vec(kpt,AA_R,OO_true=AA)

    do i=1,3
       AA(:,:,i)=utility_rotate(AA(:,:,i),UU,num_wann)
    enddo
    AA=AA+cmplx_i*D_h ! Eq.(25) WYSV06

    ! write files
    print *, "I am writing files"
    do i=1,num_wann
      do j=1,num_wann
        write(a_unit, '(F14.7," ",F14.7," ")', advance='no') AA(i,j,1)
        write(a_unit, '(F14.7," ",F14.7," ")', advance='no') AA(i,j,2)
        write(a_unit, '(F14.7," ",F14.7)') AA(i,j,3)
      end do
    end do
    do i=1,num_wann
      do j=1,num_wann
        write(u_unit, '(F14.7," ",F14.7," ")') UU(i,j)
      end do
    end do
  end do
  close(a_unit)
  close(u_unit)
  !!! END OF MY PROGRAM

  ! I put a barrier here before calling the final time printing routines,
  ! just to be sure that all processes have arrived here.
  call comms_barrier
  if(on_root) then
     write(stdout,'(/,1x,a25,f11.3,a)')&
          'Total Execution Time     ',io_time(),' (sec)'
     if (timing_level>0) call io_print_timings()
     write(stdout,*)
     write(stdout,'(/,1x,a)') 'All done: postw90 exiting'
     close(stdout)
  end if

  call comms_end

end program shift
